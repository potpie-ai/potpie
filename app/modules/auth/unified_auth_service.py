"""
Unified Authentication Service for Multi-Provider Support

Handles authentication across multiple providers (Firebase GitHub, SSO, etc.)
while maintaining single user identity based on email.
"""

import logging
import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any, List, Tuple
from sqlalchemy.orm import Session
from sqlalchemy import and_

from app.modules.integrations.token_encryption import encrypt_token, decrypt_token

# Constants
LINKING_TOKEN_LENGTH = 32  # Length of URL-safe token for provider linking
LINKING_TOKEN_EXPIRY_MINUTES = 15  # Expiration time for pending provider links

# Provider Type Constants
PROVIDER_TYPE_FIREBASE_GITHUB = "firebase_github"
PROVIDER_TYPE_FIREBASE_EMAIL = "firebase_email_password"
PROVIDER_TYPE_SSO_GOOGLE = "sso_google"
PROVIDER_TYPE_SSO_AZURE = "sso_azure"
PROVIDER_TYPE_SSO_OKTA = "sso_okta"
PROVIDER_TYPE_SSO_SAML = "sso_saml"


# Use timezone-aware datetime.now() instead of deprecated utcnow()
def utc_now() -> datetime:
    """Get current UTC time as timezone-aware datetime"""
    return datetime.now(timezone.utc)


from app.modules.auth.sso_providers import (
    BaseSSOProvider,
)
from app.modules.auth.sso_providers.provider_registry import SSOProviderRegistry

from app.modules.auth.auth_provider_model import (
    UserAuthProvider,
    PendingProviderLink,
    OrganizationSSOConfig,
    AuthAuditLog,
)
from app.modules.users.user_model import User
from app.modules.users.user_service import UserService
from app.modules.auth.auth_schema import (
    AuthProviderCreate,
    SSOLoginResponse,
)

logger = logging.getLogger(__name__)


class UnifiedAuthService:
    """
    Service for handling multi-provider authentication and account linking.

    Key responsibilities:
    - Authenticate users across multiple providers
    - Link new providers to existing accounts
    - Prevent account duplication
    - Manage provider preferences
    """

    def __init__(self, db: Session):
        self.db = db
        self.user_service = UserService(db)

        # Get singleton SSO provider instances from registry
        # Providers are stateless and can be safely shared across requests
        self.sso_providers: Dict[str, BaseSSOProvider] = (
            SSOProviderRegistry.get_all_providers()
        )

    def get_sso_provider(self, provider_name: str) -> Optional[BaseSSOProvider]:
        """Get SSO provider by name"""
        return self.sso_providers.get(provider_name.lower())

    async def verify_sso_token(
        self, provider_name: str, id_token: str
    ) -> Optional[Any]:
        """
        Verify an SSO ID token using the appropriate provider.

        Returns SSOUserInfo if valid, None if invalid.
        """
        provider = self.get_sso_provider(provider_name)
        if not provider:
            logger.error("Unknown SSO provider: %s", provider_name)
            return None

        try:
            user_info = await provider.verify_token(id_token)
            return user_info
        except ValueError as e:
            logger.error("Token verification failed for %s: %s", provider_name, str(e))
            return None

    # ===== Provider Management =====

    def get_user_providers(self, user_id: str) -> List[UserAuthProvider]:
        """Get all auth providers for a user"""
        return (
            self.db.query(UserAuthProvider)
            .filter(UserAuthProvider.user_id == user_id)
            .order_by(
                UserAuthProvider.is_primary.desc(), UserAuthProvider.linked_at.desc()
            )
            .all()
        )

    def get_provider(
        self, user_id: str, provider_type: str
    ) -> Optional[UserAuthProvider]:
        """Get a specific provider for a user"""
        return (
            self.db.query(UserAuthProvider)
            .filter(
                and_(
                    UserAuthProvider.user_id == user_id,
                    UserAuthProvider.provider_type == provider_type,
                )
            )
            .first()
        )

    def get_decrypted_access_token(
        self, user_id: str, provider_type: str
    ) -> Optional[str]:
        """
        Get decrypted access token for a user's provider.

        Returns None if provider not found or token not available.
        Handles both encrypted and plaintext tokens (backward compatibility).
        """
        provider = self.get_provider(user_id, provider_type)
        if not provider or not provider.access_token:
            return None

        try:
            # Try to decrypt (token is encrypted)
            return decrypt_token(provider.access_token)
        except Exception:
            # Token might be plaintext (from before encryption was added)
            # Return as-is for backward compatibility
            logger.warning(
                f"Failed to decrypt token for user {user_id}, provider {provider_type}. "
                "Assuming plaintext token (backward compatibility)."
            )
            return provider.access_token

    def get_decrypted_refresh_token(
        self, user_id: str, provider_type: str
    ) -> Optional[str]:
        """
        Get decrypted refresh token for a user's provider.

        Returns None if provider not found or token not available.
        Handles both encrypted and plaintext tokens (backward compatibility).
        """
        provider = self.get_provider(user_id, provider_type)
        if not provider or not provider.refresh_token:
            return None

        try:
            # Try to decrypt (token is encrypted)
            return decrypt_token(provider.refresh_token)
        except Exception:
            # Token might be plaintext (from before encryption was added)
            # Return as-is for backward compatibility
            logger.warning(
                "Failed to decrypt refresh token for user %s, provider %s. "
                "Assuming plaintext token (backward compatibility).",
                user_id,
                provider_type,
            )
            return provider.refresh_token

    def add_provider(
        self,
        user_id: str,
        provider_create: AuthProviderCreate,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> UserAuthProvider:
        """
        Add a new authentication provider to a user's account.

        If this is the first provider, it becomes primary.
        """
        # Check if provider already exists
        existing = self.get_provider(user_id, provider_create.provider_type)
        if existing:
            logger.warning(
                "Provider %s already exists for user %s",
                provider_create.provider_type,
                user_id,
            )
            return existing

        # Check if this is the first provider
        existing_providers = self.get_user_providers(user_id)
        is_first = len(existing_providers) == 0

        # Encrypt tokens before storing
        encrypted_access_token = (
            encrypt_token(provider_create.access_token)
            if provider_create.access_token
            else None
        )
        encrypted_refresh_token = (
            encrypt_token(provider_create.refresh_token)
            if provider_create.refresh_token
            else None
        )

        # Create new provider
        new_provider = UserAuthProvider(
            user_id=user_id,
            provider_type=provider_create.provider_type,
            provider_uid=provider_create.provider_uid,
            provider_data=provider_create.provider_data,
            access_token=encrypted_access_token,
            refresh_token=encrypted_refresh_token,
            token_expires_at=provider_create.token_expires_at,
            is_primary=is_first or provider_create.is_primary,
            linked_at=utc_now(),
            last_used_at=utc_now(),
            linked_by_ip=ip_address,
            linked_by_user_agent=user_agent,
        )

        self.db.add(new_provider)

        # If setting as primary, unset other primary providers
        if new_provider.is_primary:
            self.db.query(UserAuthProvider).filter(
                and_(
                    UserAuthProvider.user_id == user_id,
                    UserAuthProvider.id != new_provider.id,
                )
            ).update({"is_primary": False})

        self.db.commit()
        self.db.refresh(new_provider)

        # Audit log
        self._log_auth_event(
            user_id=user_id,
            event_type="link_provider",
            provider_type=provider_create.provider_type,
            status="success",
            ip_address=ip_address,
            user_agent=user_agent,
        )

        logger.info(
            "Added provider %s for user %s",
            provider_create.provider_type,
            user_id,
        )
        return new_provider

    def set_primary_provider(self, user_id: str, provider_type: str) -> bool:
        """Set a provider as the primary login method"""
        provider = self.get_provider(user_id, provider_type)
        if not provider:
            logger.warning("Provider %s not found for user %s", provider_type, user_id)
            return False

        # Unset all other primary providers
        self.db.query(UserAuthProvider).filter(
            UserAuthProvider.user_id == user_id
        ).update({"is_primary": False})

        # Set this as primary
        provider.is_primary = True
        self.db.commit()

        logger.info("Set primary provider to %s for user %s", provider_type, user_id)
        return True

    def unlink_provider(self, user_id: str, provider_type: str) -> bool:
        """
        Unlink a provider from a user's account.

        Cannot unlink if it's the only provider (would lock user out).
        If unlinking primary provider, automatically set another as primary.
        """
        provider = self.get_provider(user_id, provider_type)
        if not provider:
            logger.warning("Provider %s not found for user %s", provider_type, user_id)
            return False

        # Check if this is the only provider
        all_providers = self.get_user_providers(user_id)
        if len(all_providers) <= 1:
            logger.error(
                "Cannot unlink last provider %s for user %s",
                provider_type,
                user_id,
            )
            raise ValueError("Cannot unlink the only authentication provider")

        was_primary = provider.is_primary

        # Delete the provider
        self.db.delete(provider)
        self.db.commit()

        # If it was primary, set another as primary
        if was_primary:
            remaining = self.get_user_providers(user_id)
            if remaining:
                remaining[0].is_primary = True
                self.db.commit()

        # Audit log
        self._log_auth_event(
            user_id=user_id,
            event_type="unlink_provider",
            provider_type=provider_type,
            status="success",
        )

        logger.info("Unlinked provider %s for user %s", provider_type, user_id)
        return True

    def update_last_used(self, user_id: str, provider_type: str):
        """Update last_used_at for a provider"""
        provider = self.get_provider(user_id, provider_type)
        if provider:
            provider.last_used_at = utc_now()
            self.db.commit()

    # ===== Authentication Flow =====

    async def authenticate_or_create(
        self,
        email: str,
        provider_type: str,
        provider_uid: str,
        provider_data: Optional[Dict[str, Any]] = None,
        access_token: Optional[str] = None,
        display_name: Optional[str] = None,
        email_verified: bool = False,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> Tuple[User, SSOLoginResponse]:
        """
        Main authentication flow for any provider.

        Three scenarios:
        1. User exists with this provider → Login
        2. User exists but not this provider → Create pending link
        3. User doesn't exist → Create new user

        Returns: (User, SSOLoginResponse)
        """
        email = email.lower().strip()

        # Check if user exists by email
        existing_user = await self.user_service.get_user_by_email(email)

        if existing_user:
            # Check if this provider is already linked
            existing_provider = self.get_provider(existing_user.uid, provider_type)

            if existing_provider:
                # Scenario 1: User exists with this provider → Login
                self.update_last_used(existing_user.uid, provider_type)

                # Set this provider as primary since user is signing in with it
                # This ensures the correct email is shown in the sidebar
                if not existing_provider.is_primary:
                    logger.info(
                        "Setting %s as primary provider for user %s (user signed in with this provider)",
                        provider_type,
                        existing_user.uid,
                    )
                    self.set_primary_provider(existing_user.uid, provider_type)

                # Update last login
                existing_user.last_login_at = utc_now()
                self.db.commit()

                # Audit log
                self._log_auth_event(
                    user_id=existing_user.uid,
                    event_type="login",
                    provider_type=provider_type,
                    status="success",
                    ip_address=ip_address,
                    user_agent=user_agent,
                )

                return existing_user, SSOLoginResponse(
                    status="success",
                    user_id=existing_user.uid,
                    email=email,
                    display_name=existing_user.display_name,
                    message="Login successful",
                )
            else:
                # Scenario 2: User exists but not this provider → Create pending link
                existing_providers = [
                    p.provider_type for p in self.get_user_providers(existing_user.uid)
                ]

                linking_token = self._create_pending_link(
                    user_id=existing_user.uid,
                    provider_type=provider_type,
                    provider_uid=provider_uid,
                    provider_data=provider_data or {},
                    ip_address=ip_address,
                    user_agent=user_agent,
                )

                # Audit log
                self._log_auth_event(
                    user_id=existing_user.uid,
                    event_type="needs_linking",
                    provider_type=provider_type,
                    status="pending",
                    ip_address=ip_address,
                    user_agent=user_agent,
                )

                providers_str = ", ".join(existing_providers)
                return existing_user, SSOLoginResponse(
                    status="needs_linking",
                    user_id=existing_user.uid,
                    email=email,
                    display_name=existing_user.display_name,
                    message=f"Account exists with {providers_str}. Link this provider?",
                    linking_token=linking_token,
                    existing_providers=existing_providers,
                )
        else:
            # Scenario 3: User doesn't exist → Create new user
            new_user = self._create_user_with_provider(
                email=email,
                provider_type=provider_type,
                provider_uid=provider_uid,
                provider_data=provider_data,
                access_token=access_token,
                display_name=display_name,
                email_verified=email_verified,
                ip_address=ip_address,
                user_agent=user_agent,
            )

            # Audit log
            self._log_auth_event(
                user_id=new_user.uid,
                event_type="signup",
                provider_type=provider_type,
                status="success",
                ip_address=ip_address,
                user_agent=user_agent,
            )

            return new_user, SSOLoginResponse(
                status="new_user",
                user_id=new_user.uid,
                email=email,
                display_name=new_user.display_name,
                message="Account created successfully",
            )

    # ===== Pending Provider Links =====

    def _create_pending_link(
        self,
        user_id: str,
        provider_type: str,
        provider_uid: str,
        provider_data: Dict[str, Any],
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> str:
        """Create a pending provider link (expires in 15 minutes)"""
        token = secrets.token_urlsafe(LINKING_TOKEN_LENGTH)
        expires_at = datetime.now(timezone.utc) + timedelta(
            minutes=LINKING_TOKEN_EXPIRY_MINUTES
        )

        pending_link = PendingProviderLink(
            user_id=user_id,
            provider_type=provider_type,
            provider_uid=provider_uid,
            provider_data=provider_data,
            token=token,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent,
        )

        self.db.add(pending_link)
        self.db.commit()

        logger.info(
            "Created pending link for user %s, provider %s",
            user_id,
            provider_type,
        )
        return token

    def confirm_provider_link(self, linking_token: str) -> Optional[UserAuthProvider]:
        """
        Confirm and complete a pending provider link.

        Returns the newly linked provider or None if token invalid/expired.
        """
        pending = (
            self.db.query(PendingProviderLink)
            .filter(PendingProviderLink.token == linking_token)
            .first()
        )

        if not pending:
            logger.warning("Invalid linking token: %s", linking_token)
            return None

        # Check expiration - ensure both datetimes are timezone-aware
        now = datetime.now(timezone.utc)
        expires_at = pending.expires_at
        # If expires_at is naive, make it timezone-aware (assume UTC)
        if expires_at is not None and expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        # If expires_at is timezone-aware, ensure now is also timezone-aware
        elif expires_at is not None and expires_at.tzinfo is not None:
            # Both are timezone-aware, comparison should work
            pass
        logger.info(
            f"Current time (UTC): {now}, Expires at: {expires_at}, "
            f"expires_at.tzinfo: {expires_at.tzinfo if expires_at else None}"
        )
        if expires_at and expires_at < now:
            logger.warning(
                "Expired linking token: %s (expired at %s, now is %s)",
                linking_token,
                expires_at,
                now,
            )
            self.db.delete(pending)
            self.db.commit()
            return None

        logger.info("Token is valid, checking if provider already exists...")
        # Check if provider already exists (might have been added via signup endpoint)
        existing_provider = self.get_provider(pending.user_id, pending.provider_type)
        if existing_provider:
            logger.info(
                "Provider %s already exists for user %s. Provider ID: %s. Deleting pending link.",
                pending.provider_type,
                pending.user_id,
                existing_provider.id,
            )
            self.db.delete(pending)
            self.db.commit()
            return existing_provider

        logger.info("Provider doesn't exist, creating new provider...")
        try:
            # Check if user already has providers (to determine if this should be primary)
            existing_providers = self.get_user_providers(pending.user_id)
            has_existing_providers = len(existing_providers) > 0

            # When linking a provider, don't make it primary if user already has providers
            # This preserves the original sign-in method's email in the sidebar
            is_primary = (
                not has_existing_providers
            )  # Only primary if it's the first provider

            # Create the provider
            provider_create = AuthProviderCreate(
                provider_type=pending.provider_type,
                provider_uid=pending.provider_uid,
                provider_data=pending.provider_data,
                is_primary=is_primary,  # Explicitly set based on whether user has existing providers
            )
            new_provider = self.add_provider(
                user_id=pending.user_id,
                provider_create=provider_create,
                ip_address=pending.ip_address,
                user_agent=pending.user_agent,
            )

            # Delete the pending link
            self.db.delete(pending)
            self.db.commit()

            logger.info(
                "Confirmed provider link for user %s, provider %s",
                pending.user_id,
                pending.provider_type,
            )
            return new_provider
        except Exception as e:
            logger.error("Error confirming provider link: %s", str(e), exc_info=True)
            self.db.rollback()
            raise

    def cancel_pending_link(self, linking_token: str) -> bool:
        """Cancel a pending provider link"""
        pending = (
            self.db.query(PendingProviderLink)
            .filter(PendingProviderLink.token == linking_token)
            .first()
        )

        if pending:
            self.db.delete(pending)
            self.db.commit()
            logger.info("Cancelled pending link: %s", linking_token)
            return True

        return False

    # ===== Helper Methods =====

    def _create_user_with_provider(
        self,
        email: str,
        provider_type: str,
        provider_uid: str,
        provider_data: Optional[Dict[str, Any]],
        access_token: Optional[str],
        display_name: Optional[str],
        email_verified: bool,
        ip_address: Optional[str],
        user_agent: Optional[str],
    ) -> User:
        """Create a new user with their first auth provider"""
        # Extract organization from email using utility function
        from app.modules.utils.email_helper import extract_organization_from_email

        organization = extract_organization_from_email(email)

        # Create user
        new_user = User(
            uid=provider_uid,  # Use provider UID as user ID initially
            email=email,
            display_name=display_name or email.split("@")[0],
            email_verified=email_verified,
            organization=organization,
            created_at=utc_now(),
            last_login_at=utc_now(),
        )

        self.db.add(new_user)
        self.db.flush()  # Get the user ID

        # Encrypt token before storing
        encrypted_access_token = encrypt_token(access_token) if access_token else None

        # Create provider
        provider = UserAuthProvider(
            user_id=new_user.uid,
            provider_type=provider_type,
            provider_uid=provider_uid,
            provider_data=provider_data,
            access_token=encrypted_access_token,
            is_primary=True,  # First provider is always primary
            linked_at=utc_now(),
            last_used_at=utc_now(),
            linked_by_ip=ip_address,
            linked_by_user_agent=user_agent,
        )

        self.db.add(provider)
        self.db.commit()
        self.db.refresh(new_user)

        logger.info("Created new user %s with provider %s", new_user.uid, provider_type)
        return new_user

    def _log_auth_event(
        self,
        user_id: Optional[str],
        event_type: str,
        provider_type: Optional[str],
        status: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        error_message: Optional[str] = None,
    ):
        """Log an authentication event to audit log"""
        log_entry = AuthAuditLog(
            user_id=user_id,
            event_type=event_type,
            provider_type=provider_type,
            status=status,
            ip_address=ip_address,
            user_agent=user_agent,
            error_message=error_message,
        )

        self.db.add(log_entry)
        self.db.commit()

    # ===== Organization SSO Config =====

    def get_org_sso_config(self, domain: str) -> Optional[OrganizationSSOConfig]:
        """Get SSO configuration for a domain"""
        return (
            self.db.query(OrganizationSSOConfig)
            .filter(
                and_(
                    OrganizationSSOConfig.domain == domain,
                    OrganizationSSOConfig.is_active == True,
                )
            )
            .first()
        )

    def should_enforce_sso(self, email: str) -> Tuple[bool, Optional[str]]:
        """
        Check if SSO should be enforced for this email.

        Returns: (enforce_sso, sso_provider)
        """
        email_domain = email.split("@")[1] if "@" in email else None
        if not email_domain:
            return False, None

        config = self.get_org_sso_config(email_domain)
        if config and config.enforce_sso:
            return True, config.sso_provider

        return False, None
